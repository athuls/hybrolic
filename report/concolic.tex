Concolic testing [] automates test input generation by combining concrete and symbolic executions of the system under test. So the concrete part constitutes normal execution of the program while symbolic part collects symbolic constraints over the symbolic input values at each branch point encountered along concrete execution path. At the end of an execution, we have collected a set of path constraints that exercise an execution path in the system. For the next iteration, one of the constraints is negated and solved using constraint solvers to generate a new test input that directs the system along a different execution path. This process continues until all feasible distinct execution paths have been explored. When some of the symbolic constraints become too complicated for the constraint solver to generate concrete values, they are simplified by replacing some of the symbolic values with concrete values.
Concolic testing is thus sound (infers real bugs) and also allows exploring previously unreachable paths in the system. 

One of the limitations of concolic testing is that the simplification of complex (say non-linear) constraints with concrete values may result in bad approximations []. Simplified path conditions are generated by executing parts of complex constraints on concrete inputs and replacing those parts with concrete results. This may render the path condition unsatisfiable due to random input choice used to overcome constraint barriers. In order to avoid missing program paths, concolic walk proposes using results from solving linear constraints of a path condition to solve non-linear constraints via heuristic search techniques based on concrete executions. This prevents underapproximating constraints by blindly committing to concrete values. 

The technique works by visualizing the solutions to linear constraints in a path condition as an intersection of half spaces, which is a convex region. The global solution to the whole path condition must lie within this convex polytope since points outside violate the set of linear constraints. In order to search for the global solution, concolic walk employs search heuristics and a "fitness" function which measures how close the current point is to solving the non-linear constraints. By evaluating terms in the non-linear constraints, global solution search can be guided towards promising regions in the convex solution space.
 
In the context of reachability problem for singular hybrid automata discussed in section 2, let us consider an automata $\Hh$ with loops. One symbolic run in $\Hh$ could look like the following: 
\[
  r = \seq{m_0, a_1, m_1, a_2, m_1, a_2, m_1, a_3, m_2}
\] 

We can see that loop action $a_{2}$ is taken two times in the run to keep $\Hh$ in the mode $m_{1}$. The same run using transitions can be represented as   
\begin{equation}
%r = \seq{(m_0, \nu_0), (t_1, a_1), (m_1, \nu_1), \ldots, (m_k, \nu_k)}
  r = \seq{(m_0, \nu_0), (t_1, a_1), (m_1, \nu_1), (t_2, a_2), (m_1, \nu_2), (t_3, a_2), (m_1, \nu_3), (t_4, a_3), (m_2, \nu_4)}
\end{equation}
%\]

As discussed in section 5, if we treat the $t_i$'s as symbolic variables in the above trace, we can use a constraint solver to determine the concrete values for symbolic variables that satisfy above run. Note that the value of '$\textit{n}$' or number of loop iterations in above run is 2. Since we do not know the value of $\textit{n}$ that will lead us from initial mode $m_{0}$ to goal mode $m_{2}$ beforehand, we treat that as the optimization variable for our heuristic search algorithm. For every value of $\textit{n}$, we need to define a fitness function that tells us how close we are to the optimal $\textit{n}$ value, allowing us to perform a guided search in the solution space of $\textit{n}$ values. 

\subsection{Fitness function}
Given SHA $\Hh$ with goal control mode $m_{n}$, initial mode $m_{0}$ and a value $\textit{n}$ for the number of times a loop action appears in symbolic run from $m_{0}$ to $m_{n}$, we need to quantify how close this value is to generating a trace leading from initial to goal control mode in $\Hh$. Accumulating constraints from invariants and guards in the symbolic run shown in equation 1 from ($m_{0}$, $\nu_{0}$) to ($t_{4}$, $a_{3}$), we obtain the reachability set that defines a convex polyhedra in the state variable space of 
%<Give context for the technique in reachability problem for hybrid automata with loops>  
%<Introduce the algorithm/steps for our approach>
