Concolic testing~\cite{SEN07} automates test input generation by combining concrete and symbolic executions of the system under test. So the concrete part constitutes normal execution of the program while symbolic part collects symbolic constraints over the symbolic input values at each branch point encountered along concrete execution path. At the end of an execution, we have collected a set of path constraints that exercise an execution path in the system. For the next iteration, one of the constraints is negated and solved using constraint solvers to generate a new test input that directs the system along a different execution path. This process continues until all feasible distinct execution paths have been explored. When some of the symbolic constraints become too complicated for the constraint solver to generate concrete values, they are simplified by replacing some of the symbolic values with concrete values.
Concolic testing is thus sound (infers real bugs) and also allows exploring previously unreachable paths in the system. 

One of the limitations of concolic testing is that the simplification of complex (say non-linear) constraints with concrete values may result in bad approximations []. Simplified path conditions are generated by executing parts of complex constraints on concrete inputs and replacing those parts with concrete results. This may render the path condition unsatisfiable due to random input choice used to overcome constraint barriers. In order to avoid missing program paths, concolic walk proposes using results from solving linear constraints of a path condition to solve non-linear constraints via heuristic search techniques based on concrete executions. This prevents underapproximating constraints by blindly committing to concrete values. 

The technique works by visualizing the solutions to linear constraints in a path condition as an intersection of half spaces, which is a convex region. The global solution to the whole path condition must lie within this convex polytope since points outside violate the set of linear constraints. In order to search for the global solution, concolic walk employs search heuristics and a "fitness" function which measures how close the current point is to solving the non-linear constraints. By evaluating terms in the non-linear constraints, global solution search can be guided towards promising regions in the convex solution space.
 
In the context of reachability problem for singular hybrid automata discussed in section 2, let us consider an automata which has loops. A symbolic run can look like any of the following: 
\[
	r = \seq{\m_0, a_1, m_1, a_2, m_1, a_2, m_1, a_3, m_2}
\] 
<Give context for the technique in reachability problem for hybrid automata with loops>  
<Introduce the algorithm/steps for our approach>
