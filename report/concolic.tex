Concolic testing~\cite{SEN07} automates test input generation by combining concrete and symbolic executions of the system under test. So the concrete part constitutes normal execution of the program while symbolic part collects symbolic constraints over the symbolic input values at each branch point encountered along concrete execution path. At the end of an execution, we have collected a set of path constraints that exercise an execution path in the system. For the next iteration, one of the constraints is negated and solved using constraint solvers to generate a new test input that directs the system along a different execution path. This process continues until all feasible distinct execution paths have been explored. When some of the symbolic constraints become too complicated for the constraint solver to generate concrete values, they are simplified by replacing some of the symbolic values with concrete values.
Concolic testing is thus sound (infers real bugs) and also allows exploring previously unreachable paths in the system. 

One of the limitations of concolic testing is that the simplification of complex (say non-linear) constraints with concrete values may result in bad approximations []. Simplified path conditions are generated from complex constraints by executing parts of them on concrete inputs and replacing those parts with concrete results. This may render the path condition unsatisfiable due to random input choice used to overcome constraint barriers. In order to avoid missing program paths, concolic walk proposes using results from solving linear constraints of a path condition to solve non-linear constraints via heuristic search techniques based on concrete executions. This prevents underapproximating constraints by blindly committing to concrete values. <Overview of steps in the technique>

<Give context for the technique in reachability problem for hybrid automata with loops>  
<Introduce the algorithm/steps for our approach>
