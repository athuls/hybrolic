Concolic testing [] automates test input generation by combining concrete and symbolic executions of the system under test. So the concrete part constitutes normal execution of the program while symbolic part collects symbolic constraints over the symbolic input values at each branch point encountered along concrete execution path. At the end of an execution, we have collected a set of path constraints that exercise an execution path in the system. For the next iteration, one of the constraints is negated and solved using constraint solvers to generate a new test input that directs the system along a different execution path. This process continues until all feasible distinct execution paths have been explored. When some of the symbolic constraints become too complicated for the constraint solver to generate concrete values, they are simplified by replacing some of the symbolic values with concrete values.
Concolic testing is thus sound (infers real bugs) and also allows exploring previously unreachable paths in the system. 

One of the limitations of concolic testing is that the simplification of complex (or non-linear) constraints with concrete values may result in bad approximations []. Simplified path conditions are generated by executing parts of complex constraints on concrete inputs and replacing those parts with concrete results. This may render the path condition unsatisfiable due to random input choice used to overcome constraint barriers. In order to avoid missing program paths, concolic walk proposes using results from solving linear constraints of a path condition to solve non-linear constraints via heuristic search techniques based on concrete executions. This prevents underapproximating constraints by blindly committing to concrete values. 

The technique works by visualizing the solutions to linear constraints in a path condition as an intersection of half spaces, which is a convex region. The global solution to the whole path condition must lie within this convex polytope since points outside violate the set of linear constraints. In order to search for the global solution, concolic walk employs search heuristics and a "fitness" function which measures how close the current point is to solving the non-linear constraints. By evaluating terms in the non-linear constraints, global solution search can be guided towards promising regions in the convex solution space.
 
In the context of reachability problem for singular hybrid automata discussed in section 2, let us consider an automata $\Hh$ with loops. One symbolic run in $\Hh$ could look like the following: 
\[
  r = \seq{m_0, a_1, m_1, a_2, m_1, a_2, m_1, a_3, m_2}
\] 

We can see that loop action $a_{2}$ is taken two times in the run to keep $\Hh$ in the mode $m_{1}$. The same run using transitions can be represented as   
\begin{equation}
%r = \seq{(m_0, \nu_0), (t_1, a_1), (m_1, \nu_1), \ldots, (m_k, \nu_k)}
  r = \seq{(m_0, \nu_0), (t_1, a_1), (m_1, \nu_1), (t_2, a_2), (m_1, \nu_2), (t_3, a_2), (m_1, \nu_3), (t_4, a_3), (m_2, \nu_4)}
\end{equation}
%\]

As discussed in section 5, if we treat the $t_i$'s as symbolic variables in the above trace, we can use a constraint solver to determine the concrete values for symbolic variables that satisfy above run. Note that the value of '$\textit{n}$' or number of iterations for loop action $a_2$ in above run is 2. If we knew the value of $\textit{n}$ that will lead us from initial mode $m_{0}$ to target mode $m_{2}$ beforehand, we could accumulate the constraints from invariants and guards in above run and symbolically evaluate it to obtain the variable values and $t_{i}$'s that satisfy the run. Since we do not however know $\textit{n}$ and potentially infinite paths need to be considered to determine $\textit{n}$, we treat it as the optimization variable for our heuristic search algorithm. Now for every value of $\textit{n}$, we need to define a fitness function that tells us how close we are to it's optimal value, so that we can perform a guided search in the solution space of $\textit{n}$ values. 

\subsection{Fitness function}
Given SHA $\Hh$ with goal control mode $m_{n}$, initial mode $m_{0}$ and a value $\textit{n}$ for the number of times a loop action appears in symbolic run from $m_{0}$ to $m_{n}$, we need to quantify how close this value is to generating a trace leading from initial to goal control mode in $\Hh$. Accumulating constraints starting from ($m_{0}$, $\nu_{0}$) to ($t_{4}$, $a_{3}$) in equation 1 above, we obtain the reachability set that defines a convex polyhedron in the space of variables of $\Hh$. We also obtain the target set from constraints in ($m_{2}$, $\nu_{4}$), which represents our goal polyhedron. Let's say the variables in $\Hh$ are x and y, computing distance between the two polyhedra can be framed into a quadratic programming problem as: 
\begin{equation}
minimize \norm{x-y}
subject to A_{1}x <= b_{1}
and A_{2}y <= b_{2}
\end{equation}

The result of evaluating above objective function at optimal values of x and y, provides our fitness function which is an estimate of how close the reachability set is to the target set.

\subsection{Heuristic search technique}
Using the fitness function as described in previous section, we can now explore the solution space of values of $\textit{n}$ to minimize the distance between reachability set and target set. As a first step, we are implementing a simple tabu search strategy which starts with a random value of $\textit{n}$. Note that we can continue to refine the heuristic to enable quickly converging to optimal $\textit{n}$ value and handle issues such as floating point precision and Zeno effect. With the current implementation however, in each iteration, tabu search does a local neighbour search by moving from one potential solution of $\textit{n}$ to an improved one in it's neighborhood until convergence criteria is met. The convergence criteria in our case is that the polyhedron distance value (i.e. fitness function) is less than an arbitrarily small value of $\epsilon$. In order to avoid being stuck in local minima and leave large portions of search space unexplored, we store the solutions that have been visited in the recent past i.e. say solutions in the last $\textit{k}$ iterations. $\textit{k}$ here is an input parameter to the algorithm. The outcome of the search could be that: 
\begin{itemize}
\item The fitness function was less than $\epsilon$, concrete inputs obtained by symbolically solving resulting reachability/target set constraints allowed reaching the target mode.
\item Fitness function was less than $\epsilon$ but concrete inputs obtained by symbolically solving reachability/target set constraints did not allow reaching target mode. The solution in this case is unknown. This could happen because of issues such as floating point precision limitation.  
\item The maximum number of iterations was reached and no solution was obtained. This could either mean no solution exists or the heuristic failed to converge to an optimal $\textit{n}$ value within cutoff number of iterations.  
\end{itemize} 

\subsection{System block diagram}
Figure [] shows the block diagram of our entire system. A high level overview of the algorithm is as follows:

\subsection{Implementation status}
We have currently implemented configuration reader which loads an SHA with initial/target modes, guards and invariants in all intermediate modes. We have the explorer that reads the configuration and generates reachability/target sets after checking that the constraints from these sets constitute a convex system. We then have the solver that uses quadratic programming to determine the fitness function value for given reachability set, with respect to the target set. We also have the tabu search heuristic partially implemented to use the combination of explorer and solver to determine an optimal number of iterations required for executing loop action in a symbolic run, to reach target mode. We are currently working on completing the heuristic implementation and integrating the whole system to extensively test the proposed approach.   
%<Give context for the technique in reachability problem for hybrid automata with loops>  
%<Introduce the algorithm/steps for our approach>
